// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc620.Kevin.commands;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.*;
import org.usfirst.frc620.Kevin.Robot;

/**
 *
 */
public class DriveWithJoystick extends Command {
	
	/**
	 * Used by the mapstick() method to only print stuff once instead of spamming the console.
	 */
	double[] axisValues;
	
	/**
	 * Used by the mapstick() method to only print stuff once instead of spamming the console.
	 */
	boolean[] buttonPrints;
	
	/**
	 * Used by the mapstick() method to limit the frequency of prints. Don't touch unless you
	 * know what you are doing.
	 */
	private int clock = 0;
	
	/**
	 * The XBox controller. Use getRawAxis(axis) and getRawButton(button) to get data. <br>
	 * For button and axis numbers, consult will's notebook or use the mapstick() method in
	 * the main execute loop and enable prints on the console.
	 */
	Joystick stick;
	
	/**
	 * Used to ensure trigger-based code only runs once
	 */
	boolean leftTrigger = false;
	
	/**
	 * Used to ensure trigger-based code only runs once
	 */
	boolean rightTrigger = false;
	
	/**
	 * Forces the robot to go perfectly straight if the driver wants to go straight,<br>
	 * handled based on joystick input, not to be changed elsewhere in the code.
	 */
	private boolean straight = false;
	
	/**
	 * There are three speed modes: -1, 0, and 1. <br>
	 * -1 moves at 60% speed, 0 moves at 80%, 1 moves at 100%
	 */
	int speedMode = 1;
	
	/**
	 * This property determines what state of barrier mode the robot is in.<br> 
	 * The state of the barrier mode is defined by three bits:
	 *   
	 * <p>   The least significant bit (the rightmost one that determines whether the number is even or odd) determines
	 * whether the robot is currently in barrier mode.<br><br>
	 * 
	 *    The next least significant bit (the 2's place) determines whether the B key is still being held down, in
	 * order to prevent the robot's mode from toggling 50 times every second for the duration of the time the key
	 * is held down.<br><br>
	 * 
	 *    The most significant bit of the three (the 4's place) determines whether the code that runs only on state
	 * change (i.e. lowering or raising the bucket and/or pistons) has been run, and when it is a 1 only remains so
	 * for 1 execute.<br></p>
	 */
	short barrierMode = 0;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveWithJoystick() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	
    	stick = Robot.oi.getJoystick(); //Gets the joystick from the oi
    	
    	axisValues = new double[stick.getAxisCount()];
    	buttonPrints = new boolean[stick.getButtonCount()];
    	
    }
    
    /**
     * This method is called to make the robot move. This is mine, no touchy.
     */
    protected void drive() {
    	
    	double forward = 0, turn = 0, throttle = 0;
    	
    	forward = stick.getRawAxis(1);
		turn = stick.getRawAxis(0);
		
		if(!leftTrigger && stick.getRawAxis(3) > 0.7) {
			speedMode++;
			speedMode = Math.min(speedMode, 1);
		}
		if(!rightTrigger && stick.getRawAxis(2) > 0.7) {
			speedMode--;
			speedMode = Math.max(speedMode, -1);
		}
		leftTrigger = stick.getRawAxis(3) > 0.7;
		rightTrigger = stick.getRawAxis(2) > 0.7;
		
		if(speedMode == 1)
			throttle = 1.0;
		if(speedMode == 0)
			throttle = 0.8;
		if(speedMode == -1) 
			throttle = 0.6;
    	
    	if(forward > 0.9)
    		forward = 1;
    	if(Math.abs(turn)<0.2) {
    		if(!straight) {
    			
    			straight = true;
    		}
    		
    		turn = 0;
    		
    	} else
    		straight = false;
    	
    	if((barrierMode & 4) > 0)
			barrierMode ^= 4;
		if(stick.getRawButton(2)) {
			if((barrierMode & 2) == 0)
				barrierMode ^= 7;
		} else
			if(barrierMode != (barrierMode &= 5))
		 		barrierMode |= 4;
    	
		if((barrierMode & 1) > 0) {
			throttle = 0.5;
		}
		
		if((barrierMode & 6) == 6) {
			if((barrierMode & 1) == 1) {
				//TODO Setup barrier mode
			} else {
				//TODO Take down barrier mode
			}
		}
		
		Robot.driveTrain.arcadeDrive(forward * throttle, turn);
    	
    }
    
    /**
     * To use this, call it in the main execute() method and enable prints in the console.
     * Then, press buttons or move axises on the controller and it will print out what button
     * or axis you moved or pushed.
     */
    public void mapStick() {
    	clock++;
    	if(clock >= 5) {
	    	for(int x = 0; x < stick.getAxisCount(); x++) {
	    		try {
		    		if(Math.abs(stick.getRawAxis(x)-axisValues[x]) > 0.2) {
		    			System.out.println("Axis "+x+" Moved to "+stick.getRawAxis(x));
		    		}
		    		axisValues[x] = stick.getRawAxis(x);
	    		} catch(Exception e) {
	    			System.out.println(e.getMessage());
	    		}
	    	}
	    	for(int x = 1; x <= stick.getButtonCount(); x++) {
	    		try {
	    			if(stick.getRawButton(x) & !buttonPrints[x-1]) {
	    				System.out.println("Button "+x);
	    			}
	    			buttonPrints[x-1] = stick.getRawButton(x);
	    		} catch(Exception e) {
	    			System.out.println(e.getMessage());

	    		}
	    	}
	    	clock = 0;
    	}
    }
    
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	drive();
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
